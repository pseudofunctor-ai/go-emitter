package emitter

import (
	"context"
	"fmt"
	"maps"
	"os"
	"runtime"
	"strings"
	"time"

	t "github.com/pseudofunctor-ai/go-emitter/emitter/types"
)

type PassthroughHistogram struct {
	ctx     context.Context
	emitter *Emitter
	props   map[string]interface{}
	event   string
}

func (h *PassthroughHistogram) Observe(value float64) {
	h.emitter.EmitFloat(h.ctx, h.event, h.props, value, t.HISTOGRAM)
}

type eventCallSiteProps struct {
	hostname string
	filename string
	lineNo   int
	funcName string
	package_ string
}

type eventMetadata struct {
  registeredDynamically bool
	metricType            t.MetricType
	propertyKeys          []string
}

type Emitter struct {

	registeredEvents    map[string]*eventMetadata
	memoTable           map[string]eventCallSiteProps
	callback            func(context.Context, string, map[string]interface{})
	hostname_provider   func() (string, error)
	callsite_provider   func(eventName string) t.CallSiteDetails
	backends            []t.EmitterBackend
	magicHostname       bool
	magicFilename       bool
	magicLineNo         bool
	magicFuncName       bool
	magicPackage        bool
}

type TimingEmitter[T any] struct {
	emitter *Emitter
}

func NewTimingEmitter[T any](emitter *Emitter) TimingEmitter[T] {
	return TimingEmitter[T]{emitter: emitter}
}

// RuntimeCallsiteProvider is a dynamic callsite provider that uses runtime.Caller
// to determine the call site at runtime. This has runtime overhead but requires
// no code generation.
func RuntimeCallsiteProvider(eventName string) t.CallSiteDetails {
	skip := 2
	_, thisFile, _, _ := runtime.Caller(0)
	pc, file, line, ok := runtime.Caller(skip)
	// XXX: For some reason, when testing we skip 2, but elsewhere we seem to need to skip 3
	for ok && file == thisFile {
		skip += 1
		pc, file, line, ok = runtime.Caller(skip)
	}
	funcName := runtime.FuncForPC(pc).Name()

	// Extract package from function name
	// Function names are like "github.com/user/package.FunctionName"
	pkg := ""
	if lastSlash := strings.LastIndex(funcName, "/"); lastSlash >= 0 {
		if dot := strings.Index(funcName[lastSlash:], "."); dot >= 0 {
			pkg = funcName[:lastSlash+dot]
		}
	}

	return t.CallSiteDetails{
		Filename: file,
		LineNo:   line,
		FuncName: funcName,
		Package:  pkg,
	}
}

// StaticCallsiteProvider creates a callsite provider that looks up call site
// details from a static map. This is used with the go-emitter code generator
// to avoid runtime overhead of runtime.Caller.
//
// The staticData map is typically generated by the go-emitter tool and maps
// event names to their call site details.
//
// If an event name is not found in the map, it returns empty CallSiteDetails.
func StaticCallsiteProvider(staticData map[string]t.CallSiteDetails) func(string) t.CallSiteDetails {
	return func(eventName string) t.CallSiteDetails {
		if details, ok := staticData[eventName]; ok {
			return details
		}
		return t.CallSiteDetails{}
	}
}

func NewEmitter(backends ...t.EmitterBackend) *Emitter {
	return &Emitter{
		registeredEvents:  make(map[string]*eventMetadata),
		memoTable:         make(map[string]eventCallSiteProps),
		backends:          backends,
		magicHostname:     false,
		magicFilename:     false,
		magicLineNo:       false,
		magicFuncName:     false,
		magicPackage:      false,
		callback:          nil,
		hostname_provider: os.Hostname,
		callsite_provider: RuntimeCallsiteProvider,
	}
}

// NewSubEmitter creates a new emitter that inherits all configuration from the parent
// but has its own registeredEvents and memoTable. This is useful for creating
// emitters with different metadata (e.g., per-package with WithStaticMetadata)
// while sharing the same backends and providers.
//
// The returned emitter can be further configured using builder methods like
// WithStaticMetadata, WithMagicHostname, etc.
func (e *Emitter) NewSubEmitter() t.CombinedEmitter {
	// Copy the backends slice to avoid sharing the underlying array
	backendsCopy := make([]t.EmitterBackend, len(e.backends))
	copy(backendsCopy, e.backends)

	return &Emitter{
		registeredEvents:  make(map[string]*eventMetadata),
		memoTable:         make(map[string]eventCallSiteProps),
		callback:          e.callback,
		hostname_provider: e.hostname_provider,
		callsite_provider: e.callsite_provider,
		backends:          backendsCopy,
		magicHostname:     e.magicHostname,
		magicFilename:     e.magicFilename,
		magicLineNo:       e.magicLineNo,
		magicFuncName:     e.magicFuncName,
		magicPackage:      e.magicPackage,
	}
}

func (e *Emitter) WithCallback(callback func(context.Context, string, map[string]interface{})) *Emitter {
	e.callback = callback
	return e
}

func (e *Emitter) WithHostnameProvider(hostname_provider func() (string, error)) *Emitter {
	e.hostname_provider = hostname_provider
	return e
}

func (e *Emitter) WithCallsiteProvider(callsite_provider func(eventName string) t.CallSiteDetails) *Emitter {
	e.callsite_provider = callsite_provider
	return e
}

func (e *Emitter) WithBackend(backend t.EmitterBackend) *Emitter {
	e.backends = append(e.backends, backend)
	return e
}

func (e *Emitter) WithMagicHostname() *Emitter {
	e.magicHostname = true
	return e
}

func (e *Emitter) WithMagicFilename() *Emitter {
	e.magicFilename = true
	return e
}

func (e *Emitter) WithMagicLineNo() *Emitter {
	e.magicLineNo = true
	return e
}

func (e *Emitter) WithMagicFuncName() *Emitter {
	e.magicFuncName = true
	return e
}

func (e *Emitter) WithMagicPackage() *Emitter {
	e.magicPackage = true
	return e
}

func (e *Emitter) WithoutMagicProps() *Emitter {
	e.magicHostname = false
	e.magicFilename = false
	e.magicLineNo = false
	e.magicFuncName = false
	e.magicPackage = false
	return e
}

func (e *Emitter) WithAllMagicProps() *Emitter {
	return e.WithMagicHostname().WithMagicFilename().WithMagicLineNo().WithMagicFuncName().WithMagicPackage()
}

// WithStaticMetadata populates registeredEvents from statically generated metadata.
// This is typically used with a generated CallSiteDetails map from the generator tool.
// It extracts metric types and property keys from the static data.
func (e *Emitter) WithStaticMetadata(staticData map[string]t.CallSiteDetails) t.CombinedEmitter {
	for eventName, details := range staticData {
		// Parse metric type from string
		var metricType t.MetricType
		switch details.MetricType {
		case "COUNT":
			metricType = t.COUNT
		case "GAUGE":
			metricType = t.GAUGE
		case "HISTOGRAM":
			metricType = t.HISTOGRAM
		case "TIMER":
			metricType = t.TIMER
		case "METER":
			metricType = t.METER
		case "SET":
			metricType = t.SET
		case "EVENT":
			metricType = t.EVENT
		default:
			// If no metric type specified, skip registration
			continue
		}

		// Register the event with metadata
		e.registeredEvents[eventName] = &eventMetadata{
      registeredDynamically: false,
			metricType:   metricType,
			propertyKeys: details.PropertyKeys,
		}
	}

	return e
}

func (e *Emitter) Metric(event string, metricType t.MetricType) t.MetricEmitterFn {
	if re, ok := e.registeredEvents[event]; ok {
    if re.registeredDynamically {
      panic(fmt.Sprintf("Event %s already registered", event))
    }
    re.registeredDynamically = true
	} else {
    e.registeredEvents[event] = &eventMetadata{
      registeredDynamically: true,
      metricType: metricType,
      propertyKeys: nil,
    }
  }

	eCopy := *e
	silentE := (&eCopy).WithoutMagicProps()
	silentE.EmitInt(context.Background(), event, nil, 0, metricType)

	return func(ctx context.Context, props map[string]interface{}, value ...interface{}) {
    if len(value) == 0 {
      if metricType == t.COUNT {
        e.EmitInt(ctx, event, props, 1, metricType)
      } else {
        e.EmitInt(ctx, event, props, 0, metricType)
      }
      return
    }
  v := value[0]
    switch x := v.(type) {
    case int:
      e.EmitInt(ctx, event, props, int64(x), metricType)
    case int64:
      e.EmitInt(ctx, event, props, x, metricType)
    case float32:
      e.EmitFloat(ctx, event, props, float64(x), metricType)
    case float64:
      e.EmitFloat(ctx, event, props, x, metricType)
    default:
      e.ErrorfContext(ctx, event, map[string]interface{}{}, "Value must be int, int64, float32, or float64")
    }
		e.EmitInt(ctx, event, props, 1, metricType)
	}
}

func (e *Emitter) Log(event string, logfn func(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{})) t.LogEmitterFn {
	if re, ok := e.registeredEvents[event]; ok {
    if re.registeredDynamically {
      panic(fmt.Sprintf("Event %s already registered", event))
    }
    re.registeredDynamically = true
	} else {
    e.registeredEvents[event] = &eventMetadata{
      registeredDynamically: true,
      metricType: t.COUNT,
      propertyKeys: nil,
    }
  }

	eCopy := *e
	silentE := (&eCopy).WithoutMagicProps()
	silentE.EmitInt(context.Background(), event, nil, 0, t.COUNT)

	return func(ctx context.Context, props map[string]interface{}, format string, args ...interface{}) {
		logfn(ctx, event, props, format, args...)
	}
}

// MetricWithProps registers a metric with known property keys.
// It emits a zero value with placeholder values for seeding backends like Prometheus.
// The returned function validates that only expected property keys are used.
func (e *Emitter) MetricWithProps(event string, metricType t.MetricType, propKeys []string) t.MetricEmitterFn {
	if re, ok := e.registeredEvents[event]; ok {
    if re.registeredDynamically {
      panic(fmt.Sprintf("Event %s already registered", event))
    }
    re.registeredDynamically = true
	} else {
    e.registeredEvents[event] = &eventMetadata{
      registeredDynamically: true,
      metricType: metricType,
      propertyKeys: propKeys,
    }
  }

	// Create seed props with placeholder values
	seedProps := make(map[string]interface{}, len(propKeys))
	for _, key := range propKeys {
		seedProps[key] = "*"
	}

	// Emit zero with seed props for backend initialization
	eCopy := *e
	silentE := (&eCopy).WithoutMagicProps()
	silentE.EmitInt(context.Background(), event, seedProps, 0, metricType)

	// Create a set for efficient lookup
	propKeySet := make(map[string]struct{}, len(propKeys))
	for _, key := range propKeys {
		propKeySet[key] = struct{}{}
	}

	return func(ctx context.Context, props map[string]interface{}, value ...interface{}) {
		for key := range props {
			if _, ok := propKeySet[key]; !ok {
        e.ErrorfContext(ctx, event, map[string]interface{}{}, "Unexpected property key '%s' for event '%s'. Expected keys: %v", key, event, propKeys)
        return
			}
		}

    if len(value) == 0 {
      if metricType == t.COUNT {
        e.EmitInt(ctx, event, props, 1, metricType)
      } else {
        e.EmitInt(ctx, event, props, 0, metricType)
      }
      return
    }
    v := value[0]
    switch x := v.(type) {
    case int:
      e.EmitInt(ctx, event, props, int64(x), metricType)
    case int64:
      e.EmitInt(ctx, event, props, x, metricType)
    case float32:
      e.EmitFloat(ctx, event, props, float64(x), metricType)
    case float64:
      e.EmitFloat(ctx, event, props, x, metricType)
    default:
      e.ErrorfContext(ctx, event, map[string]interface{}{}, "Value must be int, int64, float32, or float64")
    }
	}
}

// LogWithProps registers a log event with known property keys.
// It emits a zero value with placeholder values for seeding backends.
// The returned function validates that only expected property keys are used.
func (e *Emitter) LogWithProps(event string, logfn func(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}), propKeys []string) t.LogEmitterFn {
	if re, ok := e.registeredEvents[event]; ok {
    if re.registeredDynamically {
      panic(fmt.Sprintf("Event %s already registered", event))
    }
    re.registeredDynamically = true
	} else {
    e.registeredEvents[event] = &eventMetadata{
      registeredDynamically: true,
      metricType: t.COUNT,
      propertyKeys: propKeys,
    }
  }

	// Create seed props with placeholder values
	seedProps := make(map[string]interface{}, len(propKeys))
	for _, key := range propKeys {
		seedProps[key] = "*"
	}

	// Emit zero with seed props for backend initialization
	eCopy := *e
	silentE := (&eCopy).WithoutMagicProps()
	silentE.EmitInt(context.Background(), event, seedProps, 0, t.COUNT)

	// Create a set for efficient lookup
	propKeySet := make(map[string]struct{}, len(propKeys))
	for _, key := range propKeys {
		propKeySet[key] = struct{}{}
	}

	return func(ctx context.Context, props map[string]interface{}, format string, args ...interface{}) {
		// Validate prop keys
		for key := range props {
			if _, ok := propKeySet[key]; !ok {
				panic(fmt.Sprintf("Unexpected property key '%s' for log event '%s'. Expected keys: %v", key, event, propKeys))
			}
		}
		logfn(ctx, event, props, format, args...)
	}
}

// MetricFnCallsite is a decorator that captures the call site where a MetricEmitterFn is used
// This is used by the generator to identify where metrics are being registered in the code
func (e *Emitter) MetricFnCallsite(fn t.MetricEmitterFn) t.MetricEmitterFn {
	// For runtime magic properties, this is a passthrough
	// For static generation, the generator will track where this is called
	return fn
}

// LogFnCallsite is a decorator that captures the call site where a LogEmitterFn is used
// This is used by the generator to identify where log events are being registered in the code
func (e *Emitter) LogFnCallsite(fn t.LogEmitterFn) t.LogEmitterFn {
	// For runtime magic properties, this is a passthrough
	// For static generation, the generator will track where this is called
	return fn
}

func (e *Emitter) addDynamicPropsToEvent(ctx context.Context, eventName string, props map[string]interface{}) map[string]interface{} {
	if props == nil {
		props = make(map[string]interface{}, 5)
	}

	// Check if we need to add any magic props or invoke callback
	if e.callback == nil && !e.magicFilename && !e.magicLineNo && !e.magicFuncName && !e.magicHostname && !e.magicPackage {
		return props
	}

	// Clone props to avoid modifying the original
	p := maps.Clone(props)

	// Get or compute the event call site props
	var eventProps *eventCallSiteProps
	if v, ok := e.memoTable[eventName]; ok {
		eventProps = &v
	} else {
		hostname, _ := e.hostname_provider()
		callsite := e.callsite_provider(eventName)
		v := eventCallSiteProps{
			hostname: hostname,
			filename: callsite.Filename,
			lineNo:   callsite.LineNo,
			funcName: callsite.FuncName,
			package_: callsite.Package,
		}
		e.memoTable[eventName] = v
		eventProps = &v
	}

	// Add magic props based on flags
	if e.magicHostname && eventProps.hostname != "" {
		p["hostname"] = eventProps.hostname
	}
	if e.magicFilename {
		p["filename"] = eventProps.filename
	}
	if e.magicLineNo {
		p["lineNo"] = eventProps.lineNo
	}
	if e.magicFuncName {
		p["funcName"] = eventProps.funcName
	}
	if e.magicPackage {
		p["package"] = eventProps.package_
	}

	if e.callback != nil {
		e.callback(ctx, eventName, p)
	}

	return p
}

// Implement EmitterBackend in case we want to stack emitters
func (e *Emitter) EmitFloat(ctx context.Context, event string, props map[string]interface{}, value float64, metricType t.MetricType) {
	p := e.addDynamicPropsToEvent(ctx, event, props)
	delete(p, "__includes_magic_props")
	for _, backend := range e.backends {
		backend.EmitFloat(ctx, event, p, value, metricType)
	}
}

func (e *Emitter) EmitInt(ctx context.Context, event string, props map[string]interface{}, value int64, metricType t.MetricType) {
	p := e.addDynamicPropsToEvent(ctx, event, props)
	delete(p, "__includes_magic_props")
	for _, backend := range e.backends {
		backend.EmitInt(ctx, event, p, value, metricType)
	}
}

func (e *Emitter) EmitDuration(ctx context.Context, event string, props map[string]interface{}, value time.Duration, metricType t.MetricType) {
	p := e.addDynamicPropsToEvent(ctx, event, props)
	delete(p, "__includes_magic_props")
	for _, backend := range e.backends {
		backend.EmitDuration(ctx, event, p, value, metricType)
	}
}

// Implement MetricsEmitter
func (e *Emitter) Count(ctx context.Context, event string, props map[string]interface{}, value int64) {
	e.EmitInt(ctx, event, props, value, t.COUNT)
}

func (e *Emitter) Gauge(ctx context.Context, event string, props map[string]interface{}, value float64) {
	e.EmitFloat(ctx, event, props, value, t.GAUGE)
}

func (e *Emitter) Histogram(ctx context.Context, event string, props map[string]interface{}) t.Histogram {
	return &PassthroughHistogram{ctx: ctx, emitter: e, event: event, props: props}
}

func (e TimingEmitter[T]) Time(ctx context.Context, event string, props map[string]interface{}, fn func() T) T {
	start := time.Now()
	r := fn()
	elapsed := time.Since(start)
	e.emitter.EmitInt(ctx, event, props, elapsed.Milliseconds(), t.TIMER)
	return r
}

func (e *Emitter) Meter(ctx context.Context, event string, props map[string]interface{}, value int64) {
	e.EmitInt(ctx, event, props, value, t.METER)
}

func (e *Emitter) Set(ctx context.Context, event string, props map[string]interface{}, value int64) {
	e.EmitInt(ctx, event, props, value, t.SET)
}

func (e *Emitter) Event(ctx context.Context, event string, props map[string]interface{}) {
	e.EmitInt(ctx, event, props, 1, t.EVENT)
}

// Implement SimpleLogger
func (e *Emitter) Info(event string, props map[string]interface{}, msg string) {
	e.InfoContext(context.Background(), event, props, msg)
}

func (e *Emitter) Warn(event string, props map[string]interface{}, msg string) {
	e.WarnContext(context.Background(), event, props, msg)
}

func (e *Emitter) Error(event string, props map[string]interface{}, msg string) {
	e.ErrorContext(context.Background(), event, props, msg)
}

func (e *Emitter) Fatal(event string, props map[string]interface{}, msg string) {
	e.FatalContext(context.Background(), event, props, msg)
}

func (e *Emitter) Debug(event string, props map[string]interface{}, msg string) {
	e.DebugContext(context.Background(), event, props, msg)
}

func (e *Emitter) Trace(event string, props map[string]interface{}, msg string) {
	e.TraceContext(context.Background(), event, props, msg)
}

// Implement FormatLogger
func (e *Emitter) Infof(event string, props map[string]interface{}, format string, args ...interface{}) {
	e.InfofContext(context.Background(), event, props, format, args...)
}

func (e *Emitter) Warnf(event string, props map[string]interface{}, format string, args ...interface{}) {
	e.WarnfContext(context.Background(), event, props, format, args...)
}

func (e *Emitter) Errorf(event string, props map[string]interface{}, format string, args ...interface{}) {
	e.ErrorfContext(context.Background(), event, props, format, args...)
}

func (e *Emitter) Fatalf(event string, props map[string]interface{}, format string, args ...interface{}) {
	e.FatalfContext(context.Background(), event, props, format, args...)
}

func (e *Emitter) Debugf(event string, props map[string]interface{}, format string, args ...interface{}) {
	e.DebugfContext(context.Background(), event, props, format, args...)
}

func (e *Emitter) Tracef(event string, props map[string]interface{}, format string, args ...interface{}) {
	e.TracefContext(context.Background(), event, props, format, args...)
}

// Implement SimpleContextLogger
func (e *Emitter) InfoContext(ctx context.Context, event string, props map[string]interface{}, msg string) {
	updatedProps := e.addDynamicPropsToEvent(ctx, event, props)
	updatedProps["_message"] = msg
	updatedProps["_logLevel"] = "INFO"
	e.EmitInt(ctx, event, updatedProps, 1, t.COUNT)
}

func (e *Emitter) WarnContext(ctx context.Context, event string, props map[string]interface{}, msg string) {
	updatedProps := e.addDynamicPropsToEvent(ctx, event, props)
	updatedProps["_message"] = msg
	updatedProps["_logLevel"] = "WARN"
	e.EmitInt(ctx, event, updatedProps, 1, t.COUNT)
}

func (e *Emitter) ErrorContext(ctx context.Context, event string, props map[string]interface{}, msg string) {
	updatedProps := e.addDynamicPropsToEvent(ctx, event, props)
	updatedProps["_message"] = msg
	updatedProps["_logLevel"] = "ERROR"
	e.EmitInt(ctx, event, updatedProps, 1, t.COUNT)
}

func (e *Emitter) FatalContext(ctx context.Context, event string, props map[string]interface{}, msg string) {
	updatedProps := e.addDynamicPropsToEvent(ctx, event, props)
	updatedProps["_message"] = msg
	updatedProps["_logLevel"] = "FATAL"
	e.EmitInt(ctx, event, updatedProps, 1, t.COUNT)
}

func (e *Emitter) DebugContext(ctx context.Context, event string, props map[string]interface{}, msg string) {
	updatedProps := e.addDynamicPropsToEvent(ctx, event, props)
	updatedProps["_message"] = msg
	updatedProps["_logLevel"] = "DEBUG"
	e.EmitInt(ctx, event, updatedProps, 1, t.COUNT)
}

func (e *Emitter) TraceContext(ctx context.Context, event string, props map[string]interface{}, msg string) {
	updatedProps := e.addDynamicPropsToEvent(ctx, event, props)
	updatedProps["_message"] = msg
	updatedProps["_logLevel"] = "TRACE"
	e.EmitInt(ctx, event, updatedProps, 1, t.COUNT)
}

// Implement FormatContextLogger
func (e *Emitter) InfofContext(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}) {
	e.InfoContext(ctx, event, props, fmt.Sprintf(format, args...))
}

func (e *Emitter) WarnfContext(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}) {
	e.WarnContext(ctx, event, props, fmt.Sprintf(format, args...))
}

func (e *Emitter) ErrorfContext(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}) {
	e.ErrorContext(ctx, event, props, fmt.Sprintf(format, args...))
}

func (e *Emitter) FatalfContext(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}) {
	e.FatalContext(ctx, event, props, fmt.Sprintf(format, args...))
}

func (e *Emitter) DebugfContext(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}) {
	e.DebugContext(ctx, event, props, fmt.Sprintf(format, args...))
}

func (e *Emitter) TracefContext(ctx context.Context, event string, props map[string]interface{}, format string, args ...interface{}) {
	e.TraceContext(ctx, event, props, fmt.Sprintf(format, args...))
}

type CompatAdapter struct {
	emitter   t.ContextLogger
	eventName string
}

func MakeCompatAdapter(eventName string, emitter t.ContextLogger) *CompatAdapter {
	return &CompatAdapter{eventName: eventName, emitter: emitter}
}

func (c *CompatAdapter) propsFromArgs(args []interface{}) map[string]interface{} {
	props := make(map[string]interface{}, len(args)/2)
	if len(args)%2 != 0 {
		panic("Props must be an even number of arguments")
	}
	for i := 0; i < len(args); i += 2 {
		props[args[i].(string)] = args[i+1]
	}
	return props
}

// Implement ContextLoggerCompat so we can use our emitter as a legacy logger
func (c *CompatAdapter) InfoContext(ctx context.Context, msg string, args ...interface{}) {
	c.emitter.InfoContext(ctx, c.eventName, c.propsFromArgs(args), msg)
}

func (c *CompatAdapter) WarnContext(ctx context.Context, msg string, args ...interface{}) {
	c.emitter.WarnContext(ctx, c.eventName, c.propsFromArgs(args), msg)
}

func (c *CompatAdapter) ErrorContext(ctx context.Context, msg string, args ...interface{}) {
	c.emitter.ErrorContext(ctx, c.eventName, c.propsFromArgs(args), msg)
}

func (c *CompatAdapter) FatalContext(ctx context.Context, msg string, args ...interface{}) {
	c.emitter.FatalContext(ctx, c.eventName, c.propsFromArgs(args), msg)
}

func (c *CompatAdapter) DebugContext(ctx context.Context, msg string, args ...interface{}) {
	c.emitter.DebugContext(ctx, c.eventName, c.propsFromArgs(args), msg)
}

func (c *CompatAdapter) TraceContext(ctx context.Context, msg string, args ...interface{}) {
	c.emitter.TraceContext(ctx, c.eventName, c.propsFromArgs(args), msg)
}

// GetManifest returns a list of all registered metrics with their types and property keys.
// This can be used to generate documentation or publish as a JSON manifest.
// Property keys use placeholder values ("*") to indicate dynamic dimensions.
func (e *Emitter) GetManifest() []t.MetricManifestEntry {
	manifest := make([]t.MetricManifestEntry, 0, len(e.registeredEvents))

	for eventName, metadata := range e.registeredEvents {
		manifest = append(manifest, t.MetricManifestEntry{
			Name:         eventName,
			MetricType:   metadata.metricType,
			TypeString:   metadata.metricType.String(),
			PropertyKeys: metadata.propertyKeys,
		})
	}

	return manifest
}
